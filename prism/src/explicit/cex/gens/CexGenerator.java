package explicit.cex.gens;

import java.util.concurrent.Callable;

import explicit.cex.cex.ProbabilisticCounterexample;
import explicit.cex.util.CexParams;
import explicit.cex.util.CexStatistics;
import explicit.cex.util.SharedMutableVar;
import explicit.cex.util.CexStatistics.FailReason;
import prism.PrismComponent;
import prism.PrismLog;

/**
 * The base class for all counterexample generators.
 * 
 * This implements the {@link java.util.concurrent.Callable} interface, since counterexample generation is best run 
 * in a separate thread. The call() method will return null if the generation did not succeed (for whatever reason).
 * Partial computation results remain accessible in this case via the {@link #forceResult()} method. 
 * 
 * This class also provides methods for setting up a statistics logging mechanism. It is enabled by passing a
 * container for the statistics to {@link #setCallBack(SharedMutableVar)}. Deriving classes should regularly check if it has been
 * enabled via {@link #shouldGenerateStats()} and, if so, log partial results via {@link #setNewStats(CexStatistics)}.
 */
public abstract class CexGenerator extends PrismComponent implements Callable<ProbabilisticCounterexample>
{
	/** Parameters for counterexample generation */
	protected final CexParams params;

	protected final PrismLog log;
	
	private long startTime = -1;
	
	/** Variable to write statistics to to propagate them to the calling thread (null if no stats desired) */
	private SharedMutableVar<CexStatistics> callBack = null;

	/** Partial result of the counterexample generation.
	 * Deriving classes must set this to a non-null value if their execution is interrupted. */
	protected ProbabilisticCounterexample partialResult = null;

	/** Flag indicating whether interrupts should be rethrown to be forwarded to the caller.
	 *  This is useful when the caller is just a wrapper running in the same thread, as is the case
	 *  for MDP generators that use DTMC generators internally */
	private boolean rethrowInterrupt = false;

	public CexGenerator(CexParams params, PrismLog log)
	{
		super();
		this.params = params;
		this.log = log;
	}
	
	/** Register call back cell for the statistics.
	 * If and once this has been set, deriving classes should regularly write new stats to the cell.
	 * @param cellForStats Cell to write this generator's stats to, or null to stop previously enabled stats generation
	 */
	public void setCallBack(SharedMutableVar<CexStatistics> cellForStats)
	{
		this.callBack = cellForStats;
	}

	/**
	 * Returns whether stats should be generated to regularly report progress 
	 * @return True iff stats should be generated
	 */
	protected boolean shouldGenerateStats()
	{
		return callBack != null;
	}

	/**
	 * Report new stats to the calling thread
	 * @param stats
	 */
	protected void setNewStats(ProbabilisticCounterexample cex)
	{
		assert (callBack != null);
		updateComputationTime(cex);
		callBack.set(cex.generateStats());
	}

	public void updateComputationTime(ProbabilisticCounterexample cex)
	{
		cex.setComputationTime(System.currentTimeMillis() - startTime);
	}

	/**
	 * Returns the current (empty/partial/complete) result of the counterexample generation.
	 * This is especially useful for accessing partial results after computation has been aborted, e.g. because of timeout. 
	 * @return The (partial) counterexample generated so far, always non-null
	 */
	public ProbabilisticCounterexample forceResult()
	{
		assert (partialResult != null);
		return partialResult;
	}
	
	/**
	 * Processes the given interrupt, modifying the given (partial) counterexample as necessary to guarantee a well-defined result
	 * @param cex (Partial) counterexample at the time of interrupt
	 * @param e Forwarded interrupt
	 * @throws InterruptedException May rethrow this to the caller, which is useful if it runs in the same thread, i.e. only wraps the counterexample generator
	 */
	protected void processInterrupt(ProbabilisticCounterexample cex, InterruptedException e) throws InterruptedException
	{
		log.println("Caught interrupt in computation for " + params + ", will return", PrismLog.VL_HIGH);
	
		// Note: It is possible that we actually have a counterexample, but don't know it because we haven't recomputed the closure. Will therefore query again if we exceed the threshold
		if (cex != null && !cex.probabilityMassExceedsThreshold()) {
			cex.setFailReason(FailReason.TIME_OUT);
			log.println(cex.generateStats());
		}
		
		// Rethrow exception if desired
		if (rethrowInterrupt) throw e;
	}
	
	/**
	 * Executes {@link #call()} in the caller's thread (blocking call).
	 * Makes the generator rethrow all interrupts to forward them to the caller.
	 * @return Counterexample generated by {@link #call()} (possibly null) 
	 * @throws Exception Any exception that occurs during the call, in particular InterruptedException
	 */
	public ProbabilisticCounterexample callFromCurrentThread() throws Exception {
		rethrowInterrupt = true;
		return call();
	}
	
	/**
	 * Starts the timer for the current computation
	 */
	protected void startTimer() {
		startTime = System.currentTimeMillis();
	}
	
	/**
	 * Saves the computation time passed so far (i.e. since the last call to {@link #startTimer()}) in the counterexample, to make it available in statistics generation. 
	 * @param cex (Partial) counterexample that is currently being computed, or null 
	 */
	protected void setComputationTime(ProbabilisticCounterexample cex)
	{
		assert(startTime >= 0);
		if (cex!=null) cex.setComputationTime(System.currentTimeMillis()-startTime);
	}
	
	@Override
	public String toString() {
		return "Generic Counterexample Generator";
	}
	
}
